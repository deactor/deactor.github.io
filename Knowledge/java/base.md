---
title:  "java地基"
---
# java相关
## java反射
+ 运行时操作类。可以通过类名创建类的class对象，可利用这个class对象可以获取实例对象，进而调用类的实例方法及属性。
+ 而且可以突破类的访问控制，访问到由private修饰的类，属性，方法。
+ 生成动态代理。还可以应用于工厂模式。
原理：
+ forname()方法会使用调用者的classLoader来加载该类，jvm加载类完成后会返回该类的class对象。
+ newInstance()方法会调用构造器生成实例。
+ 通过CAS来保证线程安全。
api要点：
+ 获取私有的方法属性需要使用getDeclaredMethod,getDeclaredMethod这种带Declared的方法。并且要设置setAccessible(true)。

----

## java泛型
优点：
+ 编译时强类型检查：泛型要求在声明时指定类型检查，Java编译器在编译时会对泛型代码做强类型检查。
+ 避免类型转换。
+ 可以利用泛型实现通用算法。

类型参数推导：
在使用泛型方法的时候，通常不必指明类型参数，编译器会为我们找出具体的类型。

类型边界：
类型只接受某个类的子类，或某个接口的实现类。
语法形式：
```
A可以是类，也可以是接口
<T extends A>
B1可以是类/接口，B2及后面的只能是接口。
<T extends B1 & B2 & B3>
```

类型擦除：
+ 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。
+ 擦除出现的类型声明，即去掉 <> 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。
+ 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。
类型擦除带来的影响：
+ 不能用于显示的引用运行时类型的操作之中，比如：转型，instanceof操作和new 表达式。
![范型类说明](https://raw.githubusercontent.com/deactor/deactor.github.io/master/imgs/java_fanxin.png)
Integer 继承了 Object；ArrayList 继承了 List；但是 List<Interger> 却并非继承了 List<Object>。 
这是因为，泛型类并没有自己独有的 Class 类对象。比如：并不存在 List<Object>.class 或是 List<Interger>.class，Java 编译器会将二者都视为 List.class。 

类型通配符：
+ 上界通配符：<? extends Number>，指明参数类型必须是Number的子类。
+ 下界通配符：<? super Integer>, 指明参数类型必须是Integer类或其父类。
+ 无界通配符：< ? > ,任意类型。
利用通配符可以实现向上转型。（泛型本身不能进行向上转型）. 

```
public class GenericsWildcardDemo {
    public static void main(String[] args) {
        List<Integer> intList = new ArrayList<>();
        List<Number> numList = intList;  // Error

        List<? extends Integer> intList2 = new ArrayList<>();
        List<? extends Number> numList2 = intList2;  // OK
    }
}
```

泛型方法：以下方法都可以作为泛型方法。
+ 普通方法
+ 静态方法
+ 构造方法

泛型约束：
![范型约束说明](https://raw.githubusercontent.com/deactor/deactor.github.io/master/imgs/java_fanxin_limit.png)

----

## java注解
Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置： 
+ SOURCE类型的注解在编译期就被丢掉了；一般用于格式检查。
+ CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；一般用于代码插入，比如ButterKnife。
+ RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。读取注解需要反射api。

# JVM相关：
## Class文件结构
二进制数据，按照JVM规定的数据格式记录类信息。包含：
+ 魔数 ：0xCAFEBABY，java class文件的标识。
+ 版本号：可被JVM处理的版本。
+ 常量表：记录所有的字面量及符号引用，比如类名，方法名，类型描述符等。字段表/方法表中记录的都是常量表中的索引。根据这些这些索引获取字段名/方法名等。
+ 类访问控制符：ACC_FINAL/ACC_PUBLIC/ACC_ABSTRACT等，表示该类或接口的访问权限及属性。
+ 类索引：记录的是类的全限定名在常量池中的索引。
+ 超类索引：记录的是超类的全限定名在常量池中的索引。
+ 类实现的接口
+ 字段表：包含字段的访问标志，字段名，字段描述信息，以及额外的属性信息（如final修饰的常量，属性信息中会记录该常量值）。同时不包含父类的字段。
+ 方法表：包含方法的访问标志，方法名，方法描述信息，以及属性信息（有一个code属性，记录的是方法的字节码，方法的最大操作数栈深度，最大局部变量表大小以及异常处理表（有try-catch时））。同时不包含父类的字段。
+ 属性表：Class文件的属性表，一般会有一个SourceFile属性，用来指明该class文件的源文件的文件名，比如test.class文件的源文件的文件名就是test.java。

----

## JVM运行时数据区
包含：
+ PC寄存器：
    + 指示当前线程所执行的字节码的行号。
    + 每个线程都有一个。
+ 元数据区（相当于之前的方法区）：
    + 存放类的结构信息，包括：
        + 类及父类名
        + 访问标志
        + 静态变量
        + 运行时常量池（class文件中的常量池会加载到这里）
        + 字段信息
        + 方法信息
        + ClassLoader引用
        + 普通方法的字节码等在class文件中存储的类信息。
    + 线程共享区域。
+ 堆内存：
    + 垃圾回收的主要区域，存放对象实例。
      + 对象的内存布局：
        + 对象头：32位/64位虚拟机中大小分别为32bit/64bit，存储GC分代年龄，锁状态标志，线程持有的锁等。
        + 实例数据：对象的实例字段。（包含从父类继承的字段）
        + 对齐填充：填充使得对象的大小为8字节的整数倍。
    + 线程共享区域。
+ java方法栈：
    + 记录java方法栈帧。栈帧包含：
        + 局部变量表
        + 操作数栈
        + 方法出口信息等
    + 线程私有区域。
+ native方法栈：
    + 记录native方法栈帧。
    + 线程私有区域。

----

## 类加载（ClassLoader要做的事情）
类加载的时机：
在类被使用的时候。

类加载过程：
加载 -> 验证 -> 准备 -> 解析 -> 初始化

加载阶段做啥：
+ 读取类的二进制字节流。
+ 将该字节流中存储的信息转化为方法区的运行时数据结构。
+ 生成class对象(在方法区中或堆中，视JVM实现而定)，作为方法区这个类的各种数据的访问人口。

验证阶段做啥：
+ 只要为了确保获取的Class字节流信息符合当前虚拟机的要求，如验证文件格式是不是以java魔数开头，版本号是否符合，验证这个类是不是继承了被final修饰的类等。

准备阶段做啥：
+ 在方法区中为类变量（非final的静态变量）分配内存并设置初始值（此处的初始值是0值）。
+ 给类常量（final static）赋编译阶段生成的ConstantValue属性中的值。

解析阶段做啥：
+ 将符号引用（字符串描述信息如“java/io/PrintStream.println”）替换为直接引用（指向目标实际内存位置的指针或句柄）。

初始化做啥：
+ 执行类初始化方法<clinit>()：给类变量赋值，执行static游离代码块。
    + 该方法是编译器自动收集类中的所有类变量的赋值动作及静态代码块中的语句合并产生的。
    + 该方法是线程安全的，当一个线程在初始化一个类时，其他线程要初始化该类时会阻塞，且当之前线程初始化结束后，其他线程被唤醒但不会执行初始化，因为初始化已经完成了。类字段是线程共享，不用再初始化。

初始化时机：
+ New一个对象，操作非final的静态字段（不包含从父类继承来的字段，且final的静态字段已经被放到常量池中，不需要触发初始化），类的静态方法被调用。
+ 反射调用时。
+ 子类初始化时如果发现父类没有初始化则先触发父类的初始化。(接口没有该要求，父接口在被用到时才初始化)。
+ 虚拟机启动时，主类（包含main方法的类）需要初始化。
+ 使用MethodHandle操作静态字段与静态方法时。
仅以上5种情形会触发，除此之外都不会触发，如：
+ 通过子类引用父类的静态字段：会触发父类的初始化，但不会触发子类的初始化。
+ 通过数组定义来引用类“Class[] clazzs = new Class[5];”：不会触发该类的初始化，而是触发了数组类的初始化。

类加载器：
+ 启动类加载器：主要加载jdk的lib目录下的类。
+ 扩展类加载器：主要加载jdk的lib/ext目录下的类。
+ 应用类加载器：主要加载用户ClassPath下的类。
双亲委派：
+ 当一个类加载器尝试加载类时，会先交给其父类加载器尝试加载，如果其父类加载器加载不了，再自己进行加载。

类加载器的几个方法：
+ loadClass(): 双亲委派模式的实现，会先查找该类是否已加载，没有则委派给父类加载加载。
+ findClass(): 读取Class字节流。
+ defineClass(): 将Class字节流转换为Class对象。父类ClassLoader实现该方法。
+ resolveClass(): 解析类符号引用。把单一的Class加入到有继承关系的类树中。

```
注意：
1. 当在类A中使用到类B，触发了类B的加载时，会使用类A的加载器来加载类B。如果类A和类B不是由同一个类加载器加载，类A是访问不到类B的。
2. 定义类加载器：实际加载类的类加载器，比如应用类加载器加载Object类，最后交给启动类加载器加载，则启动类加载器就是Object类的定义类加载器。假如最终是应用加载器来加载则应用类加载器是该类的定义类加载器。
3. 初始类加载器： 接上面，启动类加载器是定义类加载器，则启动类加载器、扩展类加载器和应用类加载器是该类的初始类加载器。如果应用类加载器是定义类加载器则只有应用类加载器是初始类加载器。
4. 命名空间：JVM会为每个类加载器维护一张表，即“命名空间”，所有以此类加载器为初始类加载的类都会记录其中。处在同命名空间内的类才能互相访问。
5. 假如类A由自定义类加载器clsloader1加载（实际是委托应用类加载器加载），类B由自定义类加载器clsloader2加载（实际也是委托应用类加载器加载），那么类A和B都在应用类加载器命名空间下，因此是可以互相访问的。
```

----

## 内存回收
GCRoots:
+ 方法区中类静态属性引用的对象。
+ 方法区中常量引用的对象。
+ java方法栈（栈帧中本地变量表）中引用的对象。
+ native方法栈中JNI引用的对象。

4种引用对内存回收的影响：
+ 强引用:  不会被回收。
+ 软引用（SoftReference）：描述一些有用但非必需的引用，被软引用关联的对象，内存不够时会被回收。
+ 弱引用（WeakReference）：描述一些非必需的引用，被弱引用关联的对象，只要gc就会被回收。
>需要注意一个对象可能有多个引用，如为对象关联了弱引用，但没有将强引用置空，那么gc仍然不会被回收。
+ 虚引用（PhantomReference）：拿不到原引用的实例，对原引用的生存时间无影响，设置虚引用的唯一目的是“在这个对象被gc回收时收到一个系统通知”。

对象自救（只有一次自救机会，finalize()只会被执行一次）：
在可达性分析算法中，真正宣告一个对象的死亡要经过两次标记过程。在第一次发现对象没有与GCRoots关联时进行一次标记并进行一次筛选。筛选指的是判断是否有必要执行finalize()方法。如果finalize()方法没有被重写，或者已经被虚拟机调用过，则认为没有必要执行。
如果是有必要执行，那么这个对象会被放到一个叫做F-Queue的队列中，稍后由虚拟机建立的Finalizer线程区执行它，但并不承诺会等待它运行结束。之后GC会对F-Queue中对象进行第二次小规模标记，如果此时发现它与GCRoots关联上了则移出“即将回收”的集合，如果仍然与GCRoots无关联，则等待回收。

垃圾回收算法：
+ 标记-清除算法：
    + 过程：
        + 先标记所有需要回收的对象，之后统一回收所有被标记的对象。
    + 缺点：
        + 效率不高
        + 会产生大量不连续的内存碎片，不利于对较大的对象分配内存
+ 复制算法：
    + 过程：
        + 将内存均分为2块，每次只使用一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后将本块内存一次性清理掉。
    + 优点：
        + 效率高，一次性回收整个半区的内存。但是当存活对象较多时，会产生大量的复制操作，这个优点就没有那么明显了。
        + 不会产生内存碎片。
    + 缺点：
        + 每次只能使用半块内存，浪费空间。
+ 标记-整理算法：
    + 过程：
        + 先标记可回收的对象，然后将存活的对象移向一端，然后直接清理掉边界以外的内存。
    + 优点：
        + 不会产生内存碎片。
        + 不浪费空间。
+ 分代收集算法：
    + 过程：
        + 根据对象存活周期的不同将内存划分为几块，一般将堆分为新生代和老年代。新生代中对象死的多活得少，采用复制算法回收；老年代活的多死得少，没有额外空间做分配担保，使用标记-清除或标记-整理算法进行回收。
    + 优点：
        + 根据对象存活周期的不同来采用不同的算法回收，最大化内存利用率和回收效率。

垃圾回收过程：
+ 垃圾回收触发时机：一般新生代会分为三个部分，一个Eden区和两个Survivor区（Eden区比两个Survivor区都大）。当Eden区满时就会触发垃圾回收。
+ 回收过程：Eden区满后触发新生代gc（minor gc），会标记Eden区和Survivor的From区，将存活的对象复制到Survivor的To区，把Eden区和From区清空，同时To改为From区，From区改为To区。如果To区放不下，那就会将对象复制到老年代，如果From区中有对象在多次回收中存活达到了晋升年龄则也会被复制到老年代。如果老年代的空间达到一定阀值，则进行老年代gc（major gc）。

三种GC：
+ Minor GC:
    + 新生代gc，回收Eden和Survivor区。
    + 触发条件：
        + Eden区满
+ Major GC：（根据垃圾收集器的实现，可能实现为只回收老年代，也可能实现为full gc）
    + 老年代gc，回收老年代。通常会出现至少一次MinorGC。
    + 触发条件：
        + 老年代空间不足。
+ Full GC：
    + 针对整个新生代，老年代，方法区的全局范围的GC。
    + 触发条件：
        + 老年代空间不足，如创建一个大对象，Eden区放不下，老年代也放不下。
        + 方法区不足。
        + 显示调用System.gc，但并不一定会立马触发，只是接下来的一次gc是full gc。

Stop-The-World：
+ 在可达性分析过程中必须要保证对象的引用关系不会变化，否则就没法确保分析的准确性，就必须停顿所有的java执行线程，即Stop-The-World。
+ GC过程中Stop-The-Wrold是必然的，新生代的回收比较快，停顿时间短，对程序影响小。Full GC相对新生代GC造成的停顿就会较长，频繁的Full GC就比较影响性能。

安全点：
+ 同上面Stop-The-World,JVM会设置一些安全点，在安全点进行GC，不会出现引用关系变化，当需要GC时，JVM会设置中断标志，线程跑到安全点会轮询中断标志，发现需要停止就会停下来。

安全区域：
+ 一段代码片段之中，应用关系不会发生变化。
+ 可能存在JVM设置中断标志，但是线程在sleep或blocked状态，无法响应JVM的中断请求，而JVM又需要等待线程进入安全点。因此设置安全区域，当线程进入安全区域，这段时间内JVM要发起GC，JVM就不用等待该线程了，当线程唤醒时，如果GC未结束就等待GC完成可以离开安全区的信号，如果GC已结束则直接继续运行。


