---
title:  "多线程相关"
---
+ 原子性
+ 内存可见性
+ 有序性
## volatile用途及原理
volatile主要是两个作用：
+ 禁止指令重排，使得对其修饰的变量的写操作必须在读操作之前执行。
+ 控制内存可见性。
+ 从线程内存模型来说，各个线程有自己的工作内存。其操作的数据都是从进程主内存复制一份到线程工作内存中进行操作，操作之后再刷新到主内存中。volatile的作用就是对于volatile修饰的数据，每次操作后都会立即从工作内存刷新到主内存，且每次取数据也都从主内存中取。

不会进行加锁，只保证可见性，并不保证原子性。
仅在满足以下条件时使用：
+ 仅单个线程会执行写操作，或者对变量的写入不依赖当前值。
+ 该变量不会与其他状态变量一起进行不变性条件判断。
+ 访问变量时不需要加锁。（加锁即可保证可见性，因此就没有必要再用volatile了）

## synchronized用途及原理
synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这个两个字节码都需要一个引用类型的参数来指明要锁定和解锁的对象。
如果java程序中的sychronized明确指定了对象参数，那就是这个对象的引用；
如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或class对象来作为锁对象。
同时，在执行monitorenter指令时，首先尝试获取对象的锁，这个对象的对象头部分记录着获取锁的线程以及一个锁计数器。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就会阻塞等待，直到对象锁被释放。
synchronized同步块对同一条线程来说时可重入的，不会出现自己把自己锁死的问题（比如子类重写父类的synchronized方法，且内部用super调用父类，如果不可重入就会发生死锁）。

## 线程状态
+ New：创建后尚未启动
+ Runable(包含ready和running)：正在执行或者等待cpu分配时间片执行。
+ Waiting：该状态下cpu不会为其分配时间片，直到被其他线程显示唤醒。Object.wait()及Thread.join()都会进入该状态。
+ Timed-waiting：带有超时的Waiting。
+ Blocked：与等待不同的是，阻塞状态是指在等待着获取锁，当占有锁的线程放弃锁的时候继续执行。当线程进入同步区域时会是这种状态。
+ Terminated：线程已经结束执行的状态。

>什么是线程安全？
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

## 线程同步
>同步是什么意思？
同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。

实现方式：
+ synchronized（实际通过加锁）
+ ReenreantLock（可重入锁）
+ wait与notify（实际也还是通过锁来保证）
+ 使用atomic包中的原子变量（CAS操作保证原子性，非加锁）
+ volatile：算是轻量级的同步（无法保证原子性）
+ 线程封闭（ThreadLocal）：将所有操作的数据都封闭在线程内部，防止对其他线程产生影响。

## 锁
+ 公平锁与非公平锁：
    + 公平锁：多个线程等待同一个锁时，必须按照申请锁的时间顺序来依此获得锁。
    + 非公平锁：多个线程等待同一个锁时，在锁被释放时，任何一个线程都有机会获得锁，不按照申请时间顺序。
+ 乐观锁与悲观锁：
    + 乐观锁：先进行操作，如果没有其他线程竞争共享数据就不做额外操作，如果有竞争，再采取补偿措施（重试）。一般都不需要把线程挂起。
    + 悲观锁：无论共享数据是否真的会出现问题，都要进行加锁，维护锁计数器，切换用户态内核态。
+ ReentrantLock：可重入锁
    + lock()：获取锁
    + unlock()：释放锁
    + Condition：实现等待/通知，一个锁可以绑定多个Condition，通过这个特性可以实现选择性通知。condition.await()方法进行等待，condition.signal()进行唤醒。await和signal的调用需要在lock与unlock之间，和wait/notify要在同步块中一样。
>与synchronized的区别：（如果不是要使用下面三种特性，还是建议用原生的synchronized。）
· 等待可中断：持有锁的线程长期不释放的时候，等待的线程可以选择放弃等待，改为处理其他事情。
· 可实现公平锁：synchronized是非公平锁。
· 锁可以绑定多个条件：synchronized对于多个条件只能额外增加锁。
+ ReentrantReadWriteLock：读写锁
>读写锁有两个锁，一个是读相关的锁（也叫共享锁），一个是写相关的锁（也叫排他锁）。多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程进行写入操作时，进行读取操作的多个线程都可以获取读锁，而进行写入操作的线程只有在获取写锁后才能进行写操作。
即多个线程可以同时进行读操作，但同一时刻只允许一个线程进行写入操作。

线程调度：
+ Thread.yeild()：让出cpu资源，进入就绪状态，重新竞争时间片。有可能再次竞争到时间片继续执行，有可能竞争不到而等待下次时间片分配。一般在线程任务较重时可以使用，当自己线程需要长时间执行时，执行过程中让出一段时间的时间片让其他线程得以执行，避免一个线程长时间占用cpu资源。
线程通信：
+ Object.wait()：需要在同步方法/代码块中调用，执行wait()方法后，当前线程会释放锁（所以在执行wait方法前要时获得锁的状态），且线程进入等待状态，当被唤醒时会重新获得锁。
+ Object.notify()：也需要在同步方法/代码块中调用，如果多个线程等待，则随机唤醒其中一个，执行notify方法后，当前线程不会立即释放锁，要等到执行notity方法的线程执行完，也就是退出同步块后，当前线程开会释放锁，wait的线程才能获得锁。如果多个wait的线程只有一个线程被唤醒，且后续不再调用notify，即使释放了锁，wait的线程也会一直处于等待状态，等待状态只能通过notify唤醒或interrupt打断。
+ Object.notifyAll()：唤醒所有wait的线程进行锁竞争，获得锁的线程执行，未获得锁的线程进入阻塞状态，当锁被释放后，阻塞态的线程就会去竞争锁。
+ Thread.join()： 使所属线程正常执行，所在线程阻塞直到所属线程销毁后唤醒。join内部使用wait进行等待。线程A中执行线程B.join()。那么线程A会在此处阻塞，直到线程B销毁才会继续执行。

## AtomicXXX
原子类，其读写操作具有原子性。

## 线程池
Executors: Executor创建器。线程池都有一个LinkedBlockingQueue来存放任务。
+ newCachedThreadPool:
    + 特点：
        + 初始状态没有任何线程的线程池，有多少任务就创建多少线程，线程任务结束后线程仍会保留一段时间，超时则销毁线程。
        + 线程数最高为int值上限。
        + 其内部是创建核心线程数为0，最大线程数为Integer.MAX_VALUE，保留时间为60s。
          + 核心线程数：要一直保留的线程数，即初始线程数，且在线程回收时，回收到这个数量时就不再回收。
+ newSingleThreadExecutor:
    + 特点：
        + 只有一个线程，有多个任务时排队执行。
        + 其内部核心线程数和最大线程数都是1，且保留时间为0s。
+ newFixedThreadPool:
    + 特点：
        + 一般用来做一次性的批量操作，开启任务后执行shutdown即任务执行完就回收线程。不用手动new多个线程。
        + 线程数固定。
        + 其内部核心线程数和最大线程数相同，且保留时间为0s。
+ newScheduledThreadPool:
    + 特点：
        + 支持定时及周期性任务执行。
        + 线程数不固定。

ThreadPoolExecutor : 线程池
+ 父类：ThreadPoolExecutor -> 继承AbstractExecutorService -> 实现ExecutorService接口。
+ 构造参数：
    + corePoolSize: 核心线程数
    + maximumPoolSize：最大线程数
    + keepAliveTime：保留时间
    + unit：时间单位
    + workQueue：任务队列，存Runnable的BlockingQueue。

## Concurrent集合
![线程安全集合](https://raw.githubusercontent.com/deactor/deactor.github.io/master/imgs/java_Concurrent.png)

## ThreadLocal
变量是线程私有的。不会影响其他线程。